using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace MoreAsyncLINQ;

static partial class MoreAsyncEnumerable
{
    /// <summary>
    /// Returns a sequence of values consecutively generated by a generator function.
    /// </summary>
    /// <typeparam name="TResult">Type of elements to generate.</typeparam>
    /// <param name="initial">Value of first element in sequence</param>
    /// <param name="generator">
    /// Generator function which takes the previous series element and uses it to generate the next element.
    /// </param>
    /// <returns>A sequence containing the generated values.</returns>
    /// <remarks>
    /// This function defers element generation until needed and streams the results.
    /// </remarks>
    public static IAsyncEnumerable<TResult> GenerateAwait<TResult>(
        TResult initial,
        Func<TResult, ValueTask<TResult>> generator)
    {
        if (generator is null) throw new ArgumentNullException(nameof(generator));

        return Core(initial, generator);

        static async IAsyncEnumerable<TResult> Core(
            TResult initial,
            Func<TResult, ValueTask<TResult>> generator)
        {
            var current = initial;
            while (true)
            {
                yield return current;

                current = await generator(current).ConfigureAwait(false);
            }
        }
    }
    
    /// <summary>
    /// Returns a sequence of values consecutively generated by a generator function.
    /// </summary>
    /// <typeparam name="TResult">Type of elements to generate.</typeparam>
    /// <param name="initial">Value of first element in sequence</param>
    /// <param name="generator">
    /// Generator function which takes the previous series element and uses it to generate the next element.
    /// </param>
    /// <returns>A sequence containing the generated values.</returns>
    /// <remarks>
    /// This function defers element generation until needed and streams the results.
    /// </remarks>
    public static IAsyncEnumerable<TResult> Generate<TResult>(
        TResult initial,
        Func<TResult, CancellationToken, ValueTask<TResult>> generator)
    {
        if (generator is null) throw new ArgumentNullException(nameof(generator));

        return Core(initial, generator, default);

        static async IAsyncEnumerable<TResult> Core(
            TResult initial,
            Func<TResult, CancellationToken, ValueTask<TResult>> generator,
            [EnumeratorCancellation] CancellationToken cancellationToken)
        {
            var current = initial;
            while (true)
            {
                yield return current;

                current = await generator(current, cancellationToken);
            }
        }
    }
}